#' @name sample_with_no_fate_correction
#' @title Sample with no fate correction
#' @description This function aims to correct the samples without fate
#' @param data_connection {\link[base]{list}} expected. Either output of the function {\link[furdeb]{postgresql_dbconnection}}, which must be done before using the measure_type_control
#' @param start_year {\link[base]{integer}} expected. Starting year for the control.
#' @param end_year {\link[base]{integer}} expected. Ending year for the control.
#' @param program {\link[base]{character}} expected. Programs to be controlled. Example of the format for a program topiaid: "fr.ird.referential.ps.common.Program#1239832686262#0.31033946454061234"
#' @param ocean {\link[base]{character}} expected. Ocean to be controlled. Examples: 'Indian', 'Atlantic'...etc.
#' @param country_code {\link[base]{character}} expected. Countries on which control will be made. Examples: 'FRA', 'MUS'...etc.
#' @param corrector {\link[base]{character}} expected. First letter of the corrector's first name and last name. Examples: 'JMartin' for Jeanne Martin
#' @param action {\link[base]{character}} expected. Type of action required when update queries are launched. COMMIT is used to definitively validate modifications and make them permanent in the database. ROLLBACK is used to undo changes made. Examples: 'JMartin' for Jeanne Martin
#' @param path_file {\link[base]{character}} expected. Path to save the final xlsx.
#' @return The function corrects sample fate directly in the data base and return a xlsx file with the corrected samples.
#' @export
#' @importFrom DBI dbGetQuery sqlInterpolate SQL
#' @importFrom dplyr group_by summarise filter
#' @importFrom lubridate today
#' @importFrom openxlsx write.xlsx

sample_with_no_fate_correction <- function(data_connection,
                                           start_year,
                                           end_year,
                                           program,
                                           ocean,
                                           country_code,
                                           corrector,
                                           action,
                                           path_file = NULL) {
  # 0 - Global variables assignment ----
  new_fate_id <- NULL
  set_id <- NULL
  fao_code <- NULL
  samplemeasure_id <- NULL
  home_id <- NULL
  observer <- NULL
  fate_code <- NULL
  fate_id <- NULL
  trip_start_date <- NULL
  trip_end_date <- NULL

  # 1 - Arguments verification ----
  if (codama::r_type_checking(
    r_object = start_year,
    type = "integer",
    output = "logical"
  ) != TRUE) {
    return(codama::r_type_checking(
      r_object = start_year,
      type = "integer",
      output = "message"
    ))
  }
  if (codama::r_type_checking(
    r_object = end_year,
    type = "integer",
    output = "logical"
  ) != TRUE) {
    return(codama::r_type_checking(
      r_object = end_year,
      type = "integer",
      output = "message"
    ))
  }
  if (codama::r_type_checking(
    r_object = program,
    type = "character",
    output = "logical"
  ) != TRUE) {
    return(codama::r_type_checking(
      r_object = program,
      type = "character",
      output = "message"
    ))
  }
  if (r_type_checking(
    r_object = ocean,
    type = "character",
    output = "logical"
  ) != TRUE) {
    return(r_type_checking(
      r_object = ocean,
      type = "character",
      output = "message"
    ))
  }
  if (r_type_checking(
    r_object = country_code,
    type = "character",
    output = "logical"
  ) != TRUE) {
    return(r_type_checking(
      r_object = country_code,
      type = "character",
      output = "message"
    ))
  }
  if (codama::r_type_checking(
    r_object = corrector,
    type = "character",
    output = "logical"
  ) != TRUE) {
    return(codama::r_type_checking(
      r_object = corrector,
      type = "character",
      output = "message"
    ))
  }
  if (r_type_checking(
    r_object = action,
    type = "character",
    allowed_value = c("COMMIT", "ROLLBACK"),
    output = "logical"
  ) != TRUE) {
    return(r_type_checking(
      r_object = action,
      type = "character",
      allowed_value = c("COMMIT", "ROLLBACK"),
      output = "message"
    ))
  }
  if (!is.null(x = path_file) && codama::r_type_checking(
    r_object = path_file,
    type = "character",
    output = "logical"
  ) != TRUE) {
    return(codama::r_type_checking(
      r_object = path_file,
      type = "character",
      output = "message"
    ))
  }

  # 2 - Data extraction ----
  sample_with_no_fate <- sample_with_no_fate_control(
    data_connection = data_connection,
    start_year = start_year,
    end_year = end_year,
    program = program,
    ocean = ocean,
    country_code = country_code,
    path_file = path_file
  )
  if (data_connection[[1]] == "observe") {
    observe_species_fate_sql <- paste(readLines(con = system.file("sql",
                                                                  "observe_species_fate.sql",
                                                                  package = "codama"
    )), collapse = "\n")
    species_fate <- dplyr::tibble(DBI::dbGetQuery(
      conn = data_connection[[2]],
      statement = observe_species_fate_sql
    ))
  }
  # 3 - Query creation ----
  # Select the topiaid of the measuretype to be corrected and the topiaid of the new one
  sample_to_be_corrected <- sample_with_no_fate %>%
    dplyr::filter(!is.na(new_fate_id)) %>%
    dplyr::arrange(set_id, fao_code)
  # Topiaid of the samplemeasures to be corrected
  to_be_corrected_samplemeasure_topiaid <- paste0(
    "'",
    paste0(sample_to_be_corrected$samplemeasure_id,
           collapse = "','"
    ),
    "'"
  )
  # Topiaid of the samples to be corrected
  to_be_corrected_sample_topiaid <- paste0(
    "'",
    paste0(sample_to_be_corrected$sample_id,
           collapse = "','"
    ),
    "'"
  )
  # Queries for the correction
  queries <- list(NULL)
  ct <- 0
  timestamp <- format(lubridate::now(), "%Y%m%d_%H%M%S")
  date <- substr(timestamp, 1, 8)
  set_id_list <- unique(sample_to_be_corrected$set_id)
  for (i in seq_len(length(set_id_list))) {
    sample_set_i <- sample_to_be_corrected %>%
      dplyr::filter(set_id == set_id_list[i])
    sp_list_i <- unique(sample_set_i$fao_code)
    for (j in seq_len(length(sp_list_i))) {
      sample_set_i_sp_j <- sample_set_i %>%
        dplyr::filter(fao_code == sp_list_i[j])
      samplemeasure_id_set_i_sp_j <- unique(sample_set_i_sp_j$samplemeasure_id)
      for (k in seq_len(length(samplemeasure_id_set_i_sp_j))) {
        ct <- ct + 1
        sample_set_i_sp_j_sm_k <- sample_set_i_sp_j %>%
          dplyr::filter(samplemeasure_id == samplemeasure_id_set_i_sp_j[k])
        queries[[ct]] <- paste("UPDATE ps_observation.samplemeasure SET speciesfate = '",
                               sample_set_i_sp_j_sm_k$new_fate_id,
                               "', topiaversion = topiaversion+1, lastupdatedate = '",
                               paste(format(Sys.time(), "%Y-%m-%d %H:%M:%S"), ".000", sep = ""),
                               "' WHERE topiaid = '",
                               sample_set_i_sp_j_sm_k$samplemeasure_id,
                               "' AND speciesfate IS NULL;",
                               sep = ""
        )
      }
      ct <- ct + 1
      queries[[ct]] <- paste("UPDATE ps_observation.sample SET comment = concat(comment,'[Correction devenir NULL en devenir ",
                             species_fate$fate_code[species_fate$fate_id == sample_set_i_sp_j$new_fate_id[k]],
                             " des echantillons ",
                             sp_list_i[j],
                             " - ",
                             date,
                             " - ",
                             corrector,
                             "]')",
                             ", topiaversion = topiaversion+1, lastupdatedate = '",
                             paste(format(Sys.time(), "%Y-%m-%d %H:%M:%S"), ".000", sep = ""),
                             "' WHERE topiaid = '",
                             sample_set_i$sample_id[j],
                             "';",
                             sep = ""
      )
    }
  }
  for (k in 1:length(queries)) {
    cat("[[", k, "]] ", queries[[k]], collapse = "\n\n", sep = "")
  }

  # 4 - Query execution ----
  ## Connection to database
  con1 <- data_connection[[2]]
  cat("Number of update queries to be run : ", length(queries), "\n", sep = "")
  DBI::dbBegin(con1)
  ## Create variables to record query status
  all_completed <- TRUE
  error_occurred <- FALSE
  ## Loop start
  k <- 1
  while (k <= length(queries) & all_completed == TRUE) {
    cat("Query: ", k, "\n\n", sep = "")
    tryCatch(
      {
        result_query_k <- DBI::dbSendStatement(con1, queries[[k]])
        cat(queries[[k]], "/n")
        cat("completed :", DBI::dbGetInfo(result_query_k)$completed, "\n\n", sep = "")
        ## Update the all_completed variable if necessary
        if (DBI::dbGetInfo(result_query_k)$completed != 1) {
          all_completed <- FALSE
        }
        DBI::dbClearResult(result_query_k)
        k <- k + 1
      },
      error = function(e) {
        # In case of error, cancel the transaction
        DBI::dbRollback(con1)
        all_completed <<- FALSE
        error_occurred <<- TRUE
        print(paste("Error during query execution:", e$message))
      }
    )
  }
  ## COMMIT or ROLLBACK the modifcations
  if (all_completed & action == "COMMIT") {
    DBI::dbCommit(con1)
  } else {
    DBI::dbRollback(con1)
  }
  ## Print the information on the operation's progress
  if (all_completed & action == "COMMIT") {
    cat("All queries successfully went through", "\n", sep = "")
  } else if (action == "ROLLBACK") {
    cat("No requests have been processed as ROLLBACK was selected", "\n", sep = "")
  } else {
    cat("At least one of the queries did not go through", "\n", sep = "")
  }
  ## To be corrected samplmeasures and samples are now corrected
  corrected_samplemeasure_topiaid <- to_be_corrected_samplemeasure_topiaid
  corrected_sample_topiaid <- to_be_corrected_sample_topiaid
  ## Check modified entries by lastupdate date and topiaid
  samplemeasure_updated_lastupdatedate <- RPostgreSQL::dbGetQuery(
    con1,
    paste("SELECT * FROM ps_observation.samplemeasure WHERE lastupdatedate = '",
          Sys.Date(),
          "';",
          sep = ""
    )
  )
  View(samplemeasure_updated_lastupdatedate)
  samplemeasure_updated_topiaid <- RPostgreSQL::dbGetQuery(
    con1,
    paste("SELECT * FROM ps_observation.samplemeasure WHERE topiaid in (",
          corrected_samplemeasure_topiaid,
          ");",
          sep = ""
    )
  )
  View(samplemeasure_updated_topiaid)
  sample_updated_topiaid <- RPostgreSQL::dbGetQuery(
    con1,
    paste("SELECT * FROM ps_observation.sample WHERE topiaid in (",
          corrected_sample_topiaid,
          ");",
          sep = ""
    )
  )
  View(sample_updated_topiaid)
  ## Trips to be recalculated
  trips_to_recalculate <- sample_to_be_corrected %>%
    dplyr::group_by(
      program,
      ocean,
      home_id,
      observer,
      trip_start_date,
      trip_end_date
    ) %>%
    dplyr::summarise(.groups = "drop")
  print(trips_to_recalculate)
  # 5 - Exportation of the final check ----
  ## Data extraction to see corrected samples by the topiaid
  if (data_connection[[1]] == "observe") {
    observe_sample_corrected_sql <- paste(readLines(con = system.file("sql",
                                                                      "observe_sample.sql",
                                                                      package = "codama"
    )), collapse = "\n")
    # Correction of the sql query
    observe_sample_corrected_sql <- sub(
      pattern = "extract(year from r.date) between (?start_year) and (?end_year)\nAND p.topiaid in (?program)\nAND o.label1 in (?ocean)\nAND co.iso3code in (?country_code)",
      replacement = paste0("sm.topiaid in (", corrected_samplemeasure_topiaid, ")"),
      x = observe_sample_corrected_sql,
      fixed = TRUE
    )

    sample_corrected_data <- dplyr::tibble(DBI::dbGetQuery(
      conn = data_connection[[2]],
      statement = observe_sample_corrected_sql
    ))
  }

  # 3 - Exportation ----
  timestamp <- format(
    lubridate::now(),
    "%Y%m%d_%H%M%S"
  )
  if (!is.null(x = path_file)) {
    openxlsx::write.xlsx(sample_corrected_data,
                         file = paste0(
                           path_file,
                           "/",
                           start_year,
                           "-",
                           end_year,
                           "/sample_with_no_fate_corrected_",
                           country_code,
                           "_",
                           ocean,
                           "_",
                           start_year,
                           "-",
                           end_year,
                           "_",
                           timestamp,
                           ".xlsx"
                         ),
                         rowNames = FALSE
    )
  }
  ## Close the connection
  DBI::dbDisconnect(con1)
}
